/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class App {
    private final List<List<Integer>> input;

    public App(List<List<Integer>> input) {
        this.input = input;
    }

    public Integer getSolutionPart1() {
        var visible = 2 * input.size() + (input.get(0).size() - 2) * 2;
        for (int i = 1; i < input.size() - 1; i++) {
            for (int j = 1; j < input.get(i).size() - 1; j++) {
                var val = input.get(i).get(j);
                final var cI = i;
                final var cJ = j;
                if (IntStream.range(1, cI + 1).allMatch((di) -> val > input.get(cI - di).get(cJ)) ||
                        IntStream.range(1, input.size() - cI).allMatch((di) -> val > input.get(cI + di).get(cJ)) ||
                        IntStream.range(1, cJ + 1).allMatch((dj) -> val > input.get(cI).get(cJ - dj)) ||
                        IntStream.range(1, input.get(cI).size() - cJ).allMatch((dj) -> val > input.get(cI).get(cJ + dj))) {
                    visible++;
                }
            }
        }
        return visible;
    }

    public Integer getSolutionPart2() {
        var max = 0;
        for (int i = 1; i < input.size() - 1; i++)
            for (int j = 1; j < input.get(i).size() - 1; j++)
                max = Math.max(max, getScenicScore(i, j));
        return max;
    }

    public Integer getScenicScore(int i, int j) {
        final var val = input.get(i).get(j);
        return (int) (Math.min(IntStream.range(1, i + 1).takeWhile((di) -> val > input.get(i - di).get(j)).count() + 1, i) *
                Math.min(IntStream.range(1, input.size() - i).takeWhile((di) -> val > input.get(i + di).get(j)).count() + 1, input.size() - i - 1) *
                Math.min(IntStream.range(1, j + 1).takeWhile((dj) -> val > input.get(i).get(j - dj)).count() + 1, j) *
                Math.min(IntStream.range(1, input.get(i).size() - j).takeWhile((dj) -> val > input.get(i).get(j + dj)).count() + 1, input.get(i).size() - j - 1));
    }


    public static void main(String[] args) throws IOException {
        var input = parseInput("input.txt");
        var part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2")) System.out.println(new App(input).getSolutionPart2());
        else System.out.println(new App(input).getSolutionPart1());
    }

    private static List<List<Integer>> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename)).map((line) -> line.chars().boxed().collect(Collectors.toList())).collect(Collectors.toList());
    }
}
